#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    float time;
    vec3 cameraPos;
    vec3 cameraFront;
} ubo;

layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D img_output;

const int MAX_STEPS = 128;
const float MAX_DIST = 5.0;
const float EPSILON = 0.001;
const int MAX_RECURSION_DEPTH = 3;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    float reflectivity;
    float transparency;
    float ior;
};

mat3 rotateX(float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return mat3(
        1.0, 0.0, 0.0,
        0.0, c, -s,
        0.0, s, c
    );
}

Ray generateRay(vec2 uv) {
    vec3 right = normalize(cross(ubo.cameraFront, vec3(0.0, 1.0, 0.0)));
    vec3 up = normalize(cross(right, ubo.cameraFront));

    float fov = radians(90.0);
    float aspectRatio = 16.0 / 9.0;

    vec3 rayDir = normalize(ubo.cameraFront + uv.x * right * aspectRatio + uv.y * up);
    return Ray(ubo.cameraPos, rayDir);
}

float smoothMin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * k * (1.0 / 6.0);
}

float sphereSDF(vec3 p, vec3 center, float radius) {
    return length(p - center) - radius;
}

float torusSDF(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float sceneSDF(vec3 p, out Material material)
{
    // Positions des sphères
    vec3 sphere1Pos = vec3(0.0, 0.0, -7.0);
    vec3 sphere2Pos = vec3(0.95, 0.95, -7.0);
    vec3 sphere3Pos = vec3(-0.95, 0.95, -7.0);

    float r = 0.5;
    float k = 0.75; // blending

    // Distances SDF
    float d1 = sphereSDF(p, sphere1Pos, 0.8);
    float d2 = sphereSDF(p, sphere2Pos, r);
    float d3 = sphereSDF(p, sphere3Pos, r);

    // Smooth blend des 3 sphères
    float d12 = smoothMin(d1, d2, k);
    float dist = smoothMin(d12, d3, k);

    // Attribution du matériau selon la sphère la plus proche
    if (dist == d1) 
    {
        material.color = vec3(0.8, 0.8, 0.8);
        material.reflectivity = 0.2;
        material.transparency = 0.0;
        material.ior = 1.1;
    } else if (dist == d2)
    {
        material.color = vec3(0.8, 0.8, 0.8);
        material.reflectivity = 0.1;
        material.transparency = 0.0;
        material.ior = 1.3;
    } else {
        material.color = vec3(0.8, 0.8, 0.8);
        material.reflectivity = 0.05;
        material.transparency = 0.0;
        material.ior = 1.5;
    }

    return dist;
}

float rayMarch(Ray ray, out Material material)
{
    float distance = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ray.origin + ray.direction * distance;
        float d = sceneSDF(p, material);
        if (d < EPSILON) return distance;
        distance += d;
        if (distance > MAX_DIST) break;
    }
    return -1.0;
}

vec3 getNormal(vec3 p) 
{
    vec2 e = vec2(EPSILON, 0.0);
    Material dummyMaterial;
    return normalize(vec3(
        sceneSDF(p + e.xyy, dummyMaterial) - sceneSDF(p - e.xyy, dummyMaterial),
        sceneSDF(p + e.yxy, dummyMaterial) - sceneSDF(p - e.yxy, dummyMaterial),
        sceneSDF(p + e.yyx, dummyMaterial) - sceneSDF(p - e.yyx, dummyMaterial)
    ));
}

vec3 skyColor(vec3 dir) 
{
    float t = 0.5 * (dir.y + 1.0);
    return mix(vec3(0.7, 0.7, 1.0), vec3(0.3, 0.5, 1.0), t);
}

vec3 getColor(Ray ray, vec3 p, Material material) 
{
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);

    for (int bounce = 0; bounce < MAX_RECURSION_DEPTH; ++bounce)
    {
        vec3 normal = getNormal(p);
        bool outside = dot(ray.direction, normal) < 0.0;
        if (!outside) normal = -normal;

        // directional light
        vec3 lightDir = normalize(vec3(1.0, -1.0, -1.0));
        float diff = max(dot(normal, lightDir), 0.0);
        vec3 directLight = clamp(diff * material.color, 0.0, 1.0);

        // diffuse
        color += attenuation * (1.0 - material.reflectivity - material.transparency) * directLight;

        // reflection and refraction
        vec3 reflectDir = reflect(ray.direction, normal);
        vec3 refractDir = refract(ray.direction, normal, outside ? (1.0 / material.ior) : material.ior);

        //type of bounce
        bool useRefract = material.transparency > material.reflectivity && length(refractDir) > 0.001;
        ray = Ray(p + EPSILON * (useRefract ? refractDir : reflectDir),
                  useRefract ? refractDir : reflectDir);

        float dist = rayMarch(ray, material);
        if (dist < 0.0) {
            color += attenuation * skyColor(ray.direction);
            break;
        }

        p = ray.origin + ray.direction * dist;
        attenuation *= mix(vec3(1.0), material.color, 0.1); // légère absorption
    }

    return color;
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(img_output);

    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y)
        return;

    vec2 uv = (vec2(pixelCoord) / vec2(imageSize)) * 2.0 - 1.0;
    uv.y *= -1.0;

    Ray ray = generateRay(uv);
    Material material;
    float dist = rayMarch(ray, material);

    vec4 color = vec4(0.0);
    if (dist > 0.0) 
    {
        vec3 p = ray.origin + ray.direction * dist;
        color = vec4(getColor(ray, p, material), 1.0);
    } 
    else 
        color = vec4(skyColor(ray.direction) + vec3(0.2, 0.2, 0.0), 1.0);

    imageStore(img_output, pixelCoord, color);
}
