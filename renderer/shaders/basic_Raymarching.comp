#version 450

const int NUM_NODES = 512;

struct Node {
    vec4 boxPos;
    vec4 boxSize;
    ivec4 children;
    vec4 cloudPoints[16]; // .xyz used
};

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    float time;
    vec3 cameraPos;
    vec3 cameraFront;
    Node nodes[NUM_NODES];//8192 pour le lapin

} ubo;

layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D img_output;


const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float EPSILON = 0.001;
const int MAX_RECURSION_DEPTH = 1;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    float reflectivity;
};

mat3 rotateX(float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return mat3(
        1.0, 0.0, 0.0,
        0.0, c, -s,
        0.0, s, c
    );
}

Ray generateRay(vec2 uv) {
    vec3 right = normalize(cross(ubo.cameraFront, vec3(0.0, 1.0, 0.0)));
    vec3 up = normalize(cross(right, ubo.cameraFront));

    float fov = radians(90.0);
    float aspectRatio = 16.0 / 9.0;

    vec3 rayDir = normalize(ubo.cameraFront + uv.x * right * aspectRatio + uv.y * up);
    return Ray(ubo.cameraPos, rayDir);
}

float smoothMin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * k * (1.0 / 6.0);
}

float sphereSDF(vec3 p, vec3 center, float radius) {
    return length(p - center) - radius;
}

float torusSDF(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float boxSDF(vec3 p, vec3 center, vec3 size)
{
    // because we send min.xyz and not the real center
    center = center+size/2.0f;

    vec3 d = abs(p - center) - size/2.0f;
    return length(max(d, 0.0));
}

bool intersectAABB(vec3 p, vec3 minCorner, vec3 size)
{
    float padding = 5.0; // adapte si besoin

    vec3 maxCorner = minCorner + size;

    // Applique le padding des deux côtés
    vec3 paddedMin = minCorner - vec3(padding);
    vec3 paddedMax = maxCorner + vec3(padding);

    return all(greaterThanEqual(p, paddedMin)) && all(lessThanEqual(p, paddedMax));
}

float traverseBVH(vec3 p, float r, float k, out int outId) {
    const int MAX_STACK_SIZE = NUM_NODES;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;

    stack[stackPtr++] = 1; // commencer à la racine (node 1)

    float minDist = 1e5;
    int bestId = -1;

    int steps = 0;
    while (stackPtr > 0 && steps < 1000)
    {
        int nodeIndex = stack[--stackPtr];
        steps++;

        Node node = ubo.nodes[nodeIndex];

        // Skip si hors de la boîte englobante
        if (!intersectAABB(p, node.boxPos.xyz, node.boxSize.xyz)) {
            continue;
        }

        // Si feuille
        if (node.children.x < 1 && node.children.y < 1)
        {
            for (int i = 0; i < 16; ++i)
            {
                vec3 cp = node.cloudPoints[i].xyz;
                //if (cp == vec3(0.0)) continue; // skip points vides
                float d = sphereSDF(p, cp, r);
                if (d < minDist)
                {
                    minDist = d;
                    bestId = nodeIndex * 16 + i;
                }
            }
        } else {
            // Empiler les enfants (droite puis gauche pour LIFO)
            if (node.children.y >= 1 && stackPtr < MAX_STACK_SIZE)
                stack[stackPtr++] = node.children.y;

            if (node.children.x >= 1 && stackPtr < MAX_STACK_SIZE)
                stack[stackPtr++] = node.children.x;
        }
    }

    //print the smaller boxes
    //for (int i = 64; i < 129; ++i)
    //{
    //    float d = boxSDF(p, ubo.nodes[i].boxPos.xyz, ubo.nodes[i].boxSize.xyz);
    //    if (d < minDist) {
    //        minDist = d;
    //    }
    //}

    outId = bestId;

    return minDist;
}

float sceneSDF(vec3 p, out Material material) {
    int id = -1;
    float r = 1.0;
    float k = 0.5;

    float dist = traverseBVH(p, r, k, id); // 0 = root node

    // Couleur en fonction de l’ID
    float uniqueNumber  = float((99 * id + 1) % 5) / 5.0;
    float uniqueNumber2 = float((99 * id + 2) % 5) / 5.0;
    float uniqueNumber3 = float((99 * id + 3) % 5) / 5.0;

    material.color = vec3(uniqueNumber, uniqueNumber2, uniqueNumber3);
    material.reflectivity = 0.0;

    //for (int i = 50; i < 256; ++i)
    //{
    //    float d = sphereSDF(p, ubo.nodes[i].boxPos.xyz, length(ubo.nodes[i].boxSize));
    //    if (d < dist)
    //    {
    //        dist = d;
    //        material.color = vec3(1.0, 1.0, 0.0);
    //    }
    //}

    return dist;
}

float rayMarch(Ray ray, out Material material) {
    float distance = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ray.origin + ray.direction * distance;
        float d = sceneSDF(p, material);
        if (d < EPSILON) return distance;
        distance += d;
        if (distance > MAX_DIST) break;
    }
    return -1.0;
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(EPSILON, 0.0);
    Material dummyMaterial;
    return normalize(vec3(
        sceneSDF(p + e.xyy, dummyMaterial) - sceneSDF(p - e.xyy, dummyMaterial),
        sceneSDF(p + e.yxy, dummyMaterial) - sceneSDF(p - e.yxy, dummyMaterial),
        sceneSDF(p + e.yyx, dummyMaterial) - sceneSDF(p - e.yyx, dummyMaterial)
    ));
}

vec3 getColor(Ray ray, vec3 p, Material material) {
    vec3 color = vec3(0.0);
    vec3 attenuation = vec3(1.0);

    for (int depth = 0; depth < MAX_RECURSION_DEPTH; depth++) {
        vec3 normal = getNormal(p);
        vec3 lightDir = normalize(vec3(1.0, -1.0, -1.0));
        float diff = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = diff * material.color;

        color += attenuation * diffuse;

        vec3 reflectDir = reflect(ray.direction, normal);
        ray = Ray(p + reflectDir * EPSILON, reflectDir);
        float reflectDist = rayMarch(ray, material);
        if (reflectDist < 0.0) break;

        p = ray.origin + ray.direction * reflectDist;
        attenuation *= material.reflectivity;
    }
    return vec3(1.0, 1.0, 1.0);

    return color;
}

vec4 rabbitTest(Node node_0, Node node_1)
{
    if (
    true
    // left and right test on first element
    && node_0.children.x > -1 && node_0.children.x < 1
    && node_0.children.y > -1 && node_0.children.y < 1
    
    // left and right test on second element
    && node_1.children.x > 1 && node_1.children.x < 3
    && node_1.children.y > 2 && node_1.children.y < 4
    
    // boxPos[0] test
    && node_0.boxPos.x > -2.0f && node_0.boxPos.x < 0.0f
    && node_0.boxPos.y > -2.0f && node_0.boxPos.y < 0.0f
    && node_0.boxPos.z > -2.0f && node_0.boxPos.z < 0.0f
    
    // boxPos[1] test
    && node_1.boxPos.x > -1.0f && node_1.boxPos.x < 0.0f
    && node_1.boxPos.y > 0.0f && node_1.boxPos.y < 1.0f
    && node_1.boxPos.z > -1.0f && node_1.boxPos.z < 0.0f
    
    // boxSize[0] test
    && node_0.boxSize.x > -2.0f && node_0.boxSize.x < 0.0f
    && node_0.boxSize.y > -2.0f && node_0.boxSize.y < 0.0f
    && node_0.boxSize.z > -2.0f && node_0.boxSize.z < 0.0f
    
    // boxSize[1] test
    && node_1.boxSize.x > 0.0f && node_1.boxSize.x < 1.0f
    && node_1.boxSize.y > 0.0f && node_1.boxSize.y < 1.0f
    && node_1.boxSize.z > 0.0f && node_1.boxSize.z < 1.0f
             
    // cloudPoints[0]
    && node_0.cloudPoints[0].x > -1.0f && node_0.cloudPoints[0].x < 1.0f
    && node_0.cloudPoints[0].y > -1.0f && node_0.cloudPoints[0].y < 1.0f
    && node_0.cloudPoints[0].z > -1.0f && node_0.cloudPoints[0].z < 1.0f
    
    // cloudPoints[8] test
    //&& ubo.nodes[8].cloudPoints[0].x > -1.0f && ubo.nodes[8].cloudPoints[0].x < 1.0f
    //&& ubo.nodes[8].cloudPoints[0].y > -1.0f && ubo.nodes[8].cloudPoints[0].y < 1.0f
    //&& ubo.nodes[8].cloudPoints[0].z > -1.0f && ubo.nodes[8].cloudPoints[0].z < 1.0f
    )
        return vec4(1.0f, 0.0f, 0.0f, 0.0f);
    else
        return vec4(0.0f, 0.0f, 0.0f, 0.0f);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(img_output);

    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y)
        return;

    vec2 uv = (vec2(pixelCoord) / vec2(imageSize)) * 2.0 - 1.0;
    uv.y *= -1.0; // flip vertical (comme fragment)

    Ray ray = generateRay(uv);
    Material material;
    float dist = rayMarch(ray, material);

    vec4 color = vec4(0.0);
    if (dist > 0.0) {
        vec3 p = ray.origin + ray.direction * dist;
        color = vec4(getColor(ray, p, material), 1.0);
    }

    //color = rabbitTest(ubo.nodes[0], ubo.nodes[1]);

    imageStore(img_output, pixelCoord, color);
}
