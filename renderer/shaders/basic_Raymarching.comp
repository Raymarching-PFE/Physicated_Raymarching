#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    float time;
    vec3 cameraPos;
    vec3 cameraFront;
} ubo;

layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D img_output;

const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const int MAX_RECURSION_DEPTH = 3;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    float reflectivity;
    float transparency;
    float ior;
};

#define TOLERANCE       0.000001
#define MAX_RAY_LENGTH  16.0
#define MAX_BOUNCES     8
#define MAX_RAY_MARCHES 90

#define PI              3.141592654

float maxComp(in vec3 p) { return max(p.x, max(p.y, p.z)); }

float lengthN(in vec3 v, in float n) 
{
    v = abs(v);
    v = pow(v, vec3(n));
    return pow(v.x + v.y + v.z, 1.0 / n);
}

float sdSphere(vec3 p, float r) { return length(p) - r; }

float sdRoundCube(in vec3 p, float r) { return lengthN(p, 8.0) - r; }

float smoothMin(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

float mandelbulb(in vec3 p) 
{
    vec3 w = p;
    float m = dot(w, w);
    float dz = 1.0;
    dz = 8.0 * pow(sqrt(m), 7.0) * dz + 1.0;
    float r = length(w);
    float b = 8.0 * acos(w.y / r);
    float a = 8.0 * atan(w.x, w.z);
    vec3 v = vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));
    w = p + pow(r, 8.0) * v;
    m = dot(w, w);
    return 0.25 * log(m) * sqrt(m) / dz;
}

float sphereAndMandelbulb(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)
{
    col = vec3(0.3);
    ref = 0.2;
    trans = 0.9;
    absorb = 0.5 * vec3(1.0, 2.0, 3.0);

    float sphereSDF = sdSphere(p, 1.0);
    float sphere1SDF = sdSphere(p - vec3(1.0, 0.8, 0.0), 0.6);
    float sphere2SDF = sdSphere(p - vec3(-1.0, 0.8, 0.0), 0.6);

    float scale = 0.8;
    float mandelbulbSDF = mandelbulb(p / scale) * scale;

     float k = 0.3;

    float blendedSpheres = smoothMin(sphereSDF, sphere1SDF, k);
    blendedSpheres = smoothMin(blendedSpheres, sphere2SDF, k);

    float d = max(blendedSpheres, -mandelbulbSDF);

    if (d == sphere1SDF) {
        col = vec3(1.0, 0.5, 0.2); // orange
    }
    if (d == sphere2SDF) {
        col = vec3(0.2, 0.8, 1.0); // bleu clair
    }

    return d;
}

float sceneSDF(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb) 
{
    float i = sphereAndMandelbulb(p, col, ref, trans, absorb);

    float rc1 = sdRoundCube(p - vec3(0.0, 0.0, -5.0), 2.0);
    float rc2 = sdRoundCube(p - vec3(0.0, 0.0, 5.0), 2.0);
    float rc3 = sdRoundCube(p - vec3(-5.0, 0.0, 0.0), 2.0);
    float rc4 = sdRoundCube(p - vec3(5.0, 0.0, 0.0), 2.0);

    float d = i;
    vec3 localCol = col;
    float localRef = ref;
    float localTrans = trans;
    
    float dists[4] = float[4](rc1, rc2, rc3, rc4);
    vec3 cols[4] = vec3[4](
        vec3(1.0, 0.0, 0.0), // rc1 : rouge
        vec3(0.0, 1.0, 0.0), // rc2 : vert
        vec3(0.0, 0.0, 1.0), // rc3 : bleu
        vec3(1.0, 1.0, 0.0)  // rc4 : jaune
    );
    
    for (int j = 0; j < 4; ++j) 
    {
        if (dists[j] < d) 
        {
            d = dists[j];
            localCol = cols[j];
            localRef = 0.2;
            localTrans = 0.0;
        }
    }

    col = localCol;
    ref = localRef;
    trans = localTrans;
    return d;
}

float rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)
{
  float t = mint;
  for (int i = 0; i < MAX_RAY_MARCHES; i++)
  {
    float distance_ = sceneSDF(ro + rd*t, col, ref, trans, absorb);
    float distance = dmod*distance_;
    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;
    t += max(distance, minstep);
    rep = i;
  }
  return t;
}

vec3 getNormal(in vec3 pos)
{
  vec3 EPSILON = vec3(.0001,0.0,0.0);

  vec3 col, nor, absorb;
  float ref, trans;

  // Approximate
  return normalize(vec3(
    sceneSDF(pos+EPSILON.xyy, col, ref, trans, absorb) - sceneSDF(pos-EPSILON.xyy, col, ref, trans, absorb),
    sceneSDF(pos+EPSILON.yxy, col, ref, trans, absorb) - sceneSDF(pos-EPSILON.yxy, col, ref, trans, absorb),
    sceneSDF(pos+EPSILON.yyx, col, ref, trans, absorb) - sceneSDF(pos-EPSILON.yyx, col, ref, trans, absorb)
    ));
}

vec3 skyColor(vec3 dir) 
{
    float t = 0.5 * (dir.y + 1.0);
    return mix(vec3(0.7, 0.7, 1.0), vec3(0.3, 0.5, 1.0), t);
}

// based on mrange shader on shadertoy
vec3 render(in vec3 rayOrigin, in vec3 rayDirection)
{
    // main light
    vec3 lightPosition = vec3(2.25, 4.5, 1.5);

    vec3 accumulatedColor = vec3(0.0);
    vec3 throughput = vec3(1.0); // Atténuation

    bool isInside = false;
    float refractionIndex = 0.8;

    // raymarching settings
    float minDistance = 0.01;
    float minStep = 0.001;

    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce)
    {
        if (maxComp(throughput) < 0.01)
            break;

        float directionModifier = isInside ? -1.0 : 1.0;

        vec3 absorbance, surfaceColor;
        float reflectivity, transparency, distanceTravelled;
        int marchSteps;

        // Ray marching to find the surface distance
        distanceTravelled = rayMarch(
            directionModifier, rayOrigin, rayDirection,
            minDistance, minStep,
            marchSteps, surfaceColor, reflectivity, transparency, absorbance
        );

        vec3 hitPosition = rayOrigin + distanceTravelled * rayDirection;

        // if we touche the sky
        if (distanceTravelled >= MAX_RAY_LENGTH)
        {
            accumulatedColor += throughput * skyColor(rayDirection);
            break;
        }

        // Calculation of the normal at the surface
        vec3 normal = getNormal(hitPosition);

        // Fresnel
        float fresnel = pow(1.0 - abs(dot(normal, rayDirection)), 2.0);
        reflectivity = mix(reflectivity, 1.0, fresnel);
        transparency = mix(transparency, 0.0, fresnel);

        float currentRefraction = isInside ? 1.0 / refractionIndex : refractionIndex;
        if (isInside) normal = -normal;

        // reflect and refract the ray direction
        vec3 reflectedDir = reflect(rayDirection, normal);
        vec3 refractedDir = refract(rayDirection, normal, currentRefraction);

        // Direct lighting (Lambert)
        vec3 lightDir = normalize(lightPosition - hitPosition);
        float diffuse = max(dot(normal, lightDir), 0.0);
        float occlusion = 1.0 - float(marchSteps) / float(MAX_RAY_MARCHES);
        float lighting = diffuse * occlusion;

        // Mix color between surface color and sky color based on reflectivity
        vec3 surfaceLighting = mix(
            lighting * surfaceColor,
            skyColor(reflectedDir),
            reflectivity
        );

        vec3 absorption = vec3(1.0);

        // color accumulation depending of object refracted
        accumulatedColor += (1.0 - transparency) * throughput * absorption * surfaceLighting;
        throughput *= transparency * absorption;

        // Setup next bounce
        rayOrigin = hitPosition;
        if (length(refractedDir) < 0.001)
            rayDirection = reflectedDir;
        else
        {
            rayDirection = refractedDir;
            isInside = !isInside;
        }
    }

    return accumulatedColor;
}


// Color of the pixel depending of normalize coordinate
vec3 getColor(in vec2 pixelNDC)
{
    vec3 cameraPosition = ubo.cameraPos;
    vec3 cameraDir = ubo.cameraFront;

    vec3 forward = normalize(cameraDir);
    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up = normalize(cross(right, forward));

    float aspectRatio = 16.0 / 9.0;

    // Build ray from normalize screen coord 
    vec3 rayDirection = normalize(
        forward +
        pixelNDC.x * right * aspectRatio +
        pixelNDC.y * up
    );

    // Update for the final color
    return render(cameraPosition, rayDirection);
}

//based on mrange shader on shadertoy
vec3 postProcess(in vec3 col, in vec2 q)
{
  col=pow(clamp(col,0.0,1.0),vec3(0.75)); // gamma
  col=col*0.6+0.4*col*col*(3.0-2.0*col); // contrast
  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4); // saturation

  return col;
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(img_output);

    if (pixelCoord.x >= imageSize.x || pixelCoord.y >= imageSize.y)
        return;

    vec2 uv = (vec2(pixelCoord) / vec2(imageSize)) * 2.0 - 1.0;
    uv.y *= -1.0;

    vec3 col = getColor(uv);

    vec4 color = vec4(mix(postProcess(col, uv), vec3(1.0), 0.0), 1.0);
    
    imageStore(img_output, pixelCoord, color);
}
